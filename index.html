<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wordle Solver</title>
  <style>
    /* CSS styles for a clean, modern interface */
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
      color: #333;
      position: relative;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
    }
    #game {
      margin-top: 1rem;
    }
    .status {
      margin: 1rem 0;
      padding: 0.5rem;
      background-color: #e9ecef;
      border-radius: 4px;
    }
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    /* Styles for the individual feedback boxes */
    #feedbackContainer {
      margin-bottom: 1rem;
    }
    .feedback-box {
      width: 50px;
      height: 50px;
      font-size: 2em;
      text-align: center;
      border: 2px solid #ccc;
      border-radius: 4px;
      margin-right: 0.5rem;
      display: inline-block;
    }
    button {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 0.5rem;
    }
    button:disabled {
      background-color: #aaa;
    }
    .log-entry {
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-bottom: 1px solid #ddd;
    }
    .error {
      color: red;
    }
    /* Style for the suggested word */
    #suggestion {
      font-size: 1.8em;
      font-weight: bold;
      color: #007bff;
      border: 2px solid #007bff;
      border-radius: 4px;
      padding: 0.3em 0.6em;
      background: #e7f0fd;
      display: inline-block;
      margin-bottom: 1rem;
    }
    /* Debug panel styling */
    #debugPanel {
      display: none;
      background: #eee;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      font-size: 0.9em;
      white-space: pre-wrap;
    }
    /* Footer styling */
    footer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.8em;
      color: #777;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wordle Solver</h1>
    <div id="game">
      <div id="status" class="status">Loading word listâ€¦</div>
      <div id="solver" style="display:none;">
        <p><strong>Suggested Guess:</strong> <span id="suggestion"></span></p>
        <p><strong>Attempt:</strong> <span id="attemptCount">0</span> / 6</p>
        
        <!-- Debug Mode Toggle -->
        <div style="margin: 1rem 0;">
          <input type="checkbox" id="debugToggle">
          <label for="debugToggle">Debug Mode</label>
        </div>
        <!-- Debug Panel -->
        <div id="debugPanel"></div>
        
        <!-- Feedback input boxes -->
        <label for="feedback">Enter Feedback (5 digits, 0=gray, 1=yellow, 2=green):</label>
        <div id="feedbackContainer">
          <input type="text" class="feedback-box" id="feedback0" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback1" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback2" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback3" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback4" maxlength="1" pattern="[0-2]" inputmode="numeric">
        </div>
        <div style="margin-bottom:1rem;">
          <button id="submit">Submit Feedback</button>
          <button id="restart">Restart Game</button>
        </div>
        <div id="log"></div>
      </div>
    </div>
  </div>
  <footer>
    &copy; 2025 Ryan Lu | Licensed under GNU General Public License version 3
  </footer>
  <script>
    "use strict";

    // Constants
    const WORD_LENGTH = 5;
    const MAX_PATTERNS = Math.pow(3, WORD_LENGTH);
    const SAMPLE_SIZE = 100;
    const MAX_ATTEMPTS = 6;
    const optimalGuesses = ["salet", "crate", "raise", "roate"];

    // Global state variables
    let words = [];              // Full word list
    let remainingWords = [];     // Candidate words after filtering
    let firstGuessCache = [];    // Cache for optimal first guesses
    let cacheInitialized = false;
    let attemptCount = 0;
    let firstGuessUsed = false;
    let debugMode = false;
    let debugDetails = "";

    // UI elements
    const statusEl = document.getElementById("status");
    const solverEl = document.getElementById("solver");
    const suggestionEl = document.getElementById("suggestion");
    const attemptEl = document.getElementById("attemptCount");
    const submitButton = document.getElementById("submit");
    const restartButton = document.getElementById("restart");
    const logEl = document.getElementById("log");
    const debugPanel = document.getElementById("debugPanel");
    const debugToggle = document.getElementById("debugToggle");

    // Feedback boxes array (we have 5 boxes)
    const feedbackBoxes = Array.from(document.querySelectorAll('.feedback-box'));

    /* ------------------------------
       Utility Functions
    ------------------------------ */

    // Compute the feedback for a given guess compared to the target word.
    // Returns an array of length WORD_LENGTH with values 0 (gray), 1 (yellow), or 2 (green).
    function computeFeedback(guess, target) {
      const feedback = new Array(WORD_LENGTH).fill(0);
      const count = new Array(26).fill(0);

      // Count letters in the target word
      for (let i = 0; i < WORD_LENGTH; i++) {
        count[target.charCodeAt(i) - 97]++;
      }

      // First pass: mark greens and reduce counts
      for (let i = 0; i < WORD_LENGTH; i++) {
        if (guess[i] === target[i]) {
          feedback[i] = 2;
          count[guess.charCodeAt(i) - 97]--;
        }
      }

      // Second pass: mark yellows if available
      for (let i = 0; i < WORD_LENGTH; i++) {
        if (feedback[i] !== 2 && count[guess.charCodeAt(i) - 97] > 0) {
          feedback[i] = 1;
          count[guess.charCodeAt(i) - 97]--;
        }
      }

      return feedback;
    }

    // Calculate the entropy of a candidate word against a given list of words.
    function calculateEntropy(wordList, candidate) {
      const patternCounts = new Array(MAX_PATTERNS).fill(0);

      wordList.forEach(word => {
        const feedback = computeFeedback(candidate, word);
        let pattern = 0;
        for (let i = 0; i < WORD_LENGTH; i++) {
          pattern = pattern * 3 + feedback[i];
        }
        patternCounts[pattern]++;
      });

      let entropy = 0;
      const total = wordList.length;
      patternCounts.forEach(count => {
        if (count > 0) {
          const prob = count / total;
          entropy -= prob * Math.log2(prob);
        }
      });
      return entropy;
    }

    // Precompute the entropy for each optimal first guess.
    function precomputeFirstGuesses(wordList) {
      firstGuessCache = optimalGuesses.map(guess => {
        const ent = calculateEntropy(wordList, guess);
        return { word: guess, entropy: ent };
      });
      cacheInitialized = true;
    }

    // Return the first guess from the precomputed cache that has the maximum entropy.
    function getOptimalFirstGuess() {
      let best = firstGuessCache[0];
      firstGuessCache.forEach(item => {
        if (item.entropy > best.entropy) {
          best = item;
        }
      });
      debugDetails = "Using precomputed optimal first guess:\n";
      firstGuessCache.forEach(item => {
        debugDetails += `  ${item.word} with entropy ${item.entropy.toFixed(2)}\n`;
      });
      debugDetails += `Chosen: ${best.word}`;
      return best.word;
    }

    // For larger candidate lists, select a guess by sampling SAMPLE_SIZE random words.
    function selectEntropyGuess(wordList) {
      let maxEntropy = -Infinity;
      let bestWord = wordList[0];
      let samplesDetail = `Entropy sampling on ${wordList.length} words (${SAMPLE_SIZE} samples):\n`;
      for (let i = 0; i < SAMPLE_SIZE; i++) {
        const index = Math.floor(Math.random() * wordList.length);
        const candidate = wordList[index];
        const ent = calculateEntropy(wordList, candidate);
        samplesDetail += `  Sample ${i + 1}: ${candidate} => entropy ${ent.toFixed(2)}\n`;
        if (ent > maxEntropy) {
          maxEntropy = ent;
          bestWord = candidate;
        }
      }
      debugDetails = samplesDetail + `Chosen candidate: ${bestWord} with entropy ${maxEntropy.toFixed(2)}`;
      return bestWord;
    }

    // Calculate letter frequency counts per position.
    function calculateFrequencies(wordList) {
      const freq = Array.from({ length: WORD_LENGTH }, () => new Array(26).fill(0));
      wordList.forEach(word => {
        for (let pos = 0; pos < WORD_LENGTH; pos++) {
          freq[pos][word.charCodeAt(pos) - 97]++;
        }
      });
      return freq;
    }

    // Score a word based on letter frequencies.
    function wordScore(word, freq) {
      let score = 0;
      for (let pos = 0; pos < WORD_LENGTH; pos++) {
        score += freq[pos][word.charCodeAt(pos) - 97];
      }
      return score;
    }

    // Main guess selection logic.
    function selectGuess(wordList) {
      // On first guess, if cache available, use precomputed optimal first guess.
      if (!firstGuessUsed && cacheInitialized) {
        firstGuessUsed = true;
        return getOptimalFirstGuess();
      }
      // Use entropy sampling if candidate list is large.
      if (wordList.length > 100) {
        return selectEntropyGuess(wordList);
      }
      // Use frequency-based scoring for small candidate lists.
      const freq = calculateFrequencies(wordList);
      let bestWord = wordList[0];
      let maxScore = -1;
      let details = `Frequency-based scoring on ${wordList.length} candidates:\n`;
      wordList.forEach(word => {
        const score = wordScore(word, freq);
        details += `  ${word} => score ${score}\n`;
        if (score > maxScore) {
          maxScore = score;
          bestWord = word;
        }
      });
      debugDetails = details + `Chosen candidate: ${bestWord} with score ${maxScore}`;
      return bestWord;
    }

    // Filter candidate words based on feedback for the last guess.
    function filterWords(guess, feedback, wordList) {
      return wordList.filter(word => {
        const tempFeedback = computeFeedback(guess, word);
        for (let i = 0; i < WORD_LENGTH; i++) {
          if (tempFeedback[i] !== feedback[i]) return false;
        }
        return true;
      });
    }

    // Append a message to the log area.
    function logMessage(message, isError = false) {
      const entry = document.createElement("div");
      entry.className = "log-entry" + (isError ? " error" : "");
      entry.textContent = message;
      logEl.appendChild(entry);
    }

    /* ------------------------------
       UI & Game Logic
    ------------------------------ */

    // Update the suggestion, attempt count, and debug panel in the UI.
    function updateUI() {
      if (remainingWords.length === 0) {
        suggestionEl.textContent = "No possible words remain.";
        submitButton.disabled = true;
        return;
      }
      const guess = selectGuess(remainingWords);
      suggestionEl.textContent = guess;
      attemptEl.textContent = attemptCount.toString();
      if (debugMode) {
        debugPanel.style.display = "block";
        debugPanel.textContent = debugDetails;
      } else {
        debugPanel.style.display = "none";
      }
    }

    // Read feedback from the five individual boxes.
    function getFeedbackFromBoxes() {
      const fbArray = [];
      for (let i = 0; i < WORD_LENGTH; i++) {
        const val = feedbackBoxes[i].value.trim();
        if (!/^[0-2]$/.test(val)) {
          return null;
        }
        fbArray.push(parseInt(val, 10));
      }
      return fbArray;
    }

    // Process the feedback input.
    function processFeedback() {
      const guess = suggestionEl.textContent;
      const fbArray = getFeedbackFromBoxes();
      if (!fbArray) {
        logMessage("Invalid feedback. Please enter digits 0-2 in all boxes.", true);
        return;
      }
      const solved = fbArray.every(val => val === 2);
      logMessage(`Attempt ${attemptCount + 1}: Guess "${guess}" with feedback "${fbArray.join('')}"`);

      if (solved) {
        logMessage(`Solved in ${attemptCount + 1} attempts!`);
        suggestionEl.textContent = "âœ“";
        submitButton.disabled = true;
        feedbackBoxes.forEach(box => box.disabled = true);
        return;
      }

      remainingWords = filterWords(guess, fbArray, remainingWords);
      logMessage(`Remaining possible words: ${remainingWords.length}`);
      attemptCount++;

      if (attemptCount >= MAX_ATTEMPTS) {
        if (remainingWords.length > 1) {
          logMessage("Maximum attempts reached. Possible solutions:");
          remainingWords.slice(0, 10).forEach(word => logMessage("  " + word));
          if (remainingWords.length > 10) {
            logMessage(`... and ${remainingWords.length - 10} more`);
          }
        }
        suggestionEl.textContent = "Game Over";
        submitButton.disabled = true;
        feedbackBoxes.forEach(box => box.disabled = true);
      } else {
        // Clear all feedback boxes for the next attempt.
        feedbackBoxes.forEach(box => box.value = "");
        updateUI();
      }
    }

    // Restart the game by resetting state and UI elements.
    function restartGame() {
      attemptCount = 0;
      firstGuessUsed = false;
      remainingWords = [...words];
      logEl.innerHTML = "";
      feedbackBoxes.forEach(box => {
        box.value = "";
        box.disabled = false;
      });
      submitButton.disabled = false;
      updateUI();
    }

    /* ------------------------------
       Auto-advance for feedback boxes
    ------------------------------ */
    feedbackBoxes.forEach((box, index) => {
      box.addEventListener("input", () => {
        if (box.value.length === 1 && index < WORD_LENGTH - 1) {
          feedbackBoxes[index + 1].focus();
        }
      });
      box.addEventListener("keydown", (e) => {
        if (e.key === "Backspace" && box.value === "" && index > 0) {
          feedbackBoxes[index - 1].focus();
        }
      });
    });

    /* ------------------------------
       Debug Mode Toggle
    ------------------------------ */
    debugToggle.addEventListener("change", () => {
      debugMode = debugToggle.checked;
      if (!debugMode) {
        debugPanel.style.display = "none";
      } else {
        debugPanel.style.display = "block";
        debugPanel.textContent = debugDetails;
      }
    });

    /* ------------------------------
       Initialization: Load word list
    ------------------------------ */
    function init() {
      fetch("words.txt")
        .then(response => {
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          return response.text();
        })
        .then(text => {
          words = text.split(/\r?\n/).map(line => line.trim().toLowerCase())
                        .filter(word => word.length === WORD_LENGTH);
          if (words.length === 0) {
            throw new Error("No valid words found in words.txt");
          }
          remainingWords = [...words];
          precomputeFirstGuesses(words);
          statusEl.style.display = "none";
          solverEl.style.display = "block";
          updateUI();
        })
        .catch(error => {
          statusEl.textContent = "Error loading word list: " + error.message;
          console.error(error);
        });
    }

    document.addEventListener("DOMContentLoaded", init);
    submitButton.addEventListener("click", processFeedback);
    restartButton.addEventListener("click", restartGame);
  </script>
</body>
</html>
