<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wordle Solver – Hybrid Strategy</title>
  <style>
    /* General Styles */
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
      color: #333;
      position: relative;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
    }
    #game {
      margin-top: 1rem;
    }
    .status {
      margin: 1rem 0;
      padding: 0.5rem;
      background-color: #e9ecef;
      border-radius: 4px;
    }
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    /* Feedback Boxes */
    #feedbackContainer {
      margin-bottom: 1rem;
    }
    .feedback-box {
      width: 50px;
      height: 50px;
      font-size: 2em;
      text-align: center;
      border: 2px solid #ccc;
      border-radius: 4px;
      margin-right: 0.5rem;
      display: inline-block;
    }
    /* Button Styles */
    button {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      background-color: #007bff;
      border: none;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 0.5rem;
    }
    button:disabled {
      background-color: #aaa;
    }
    /* Log and Error Messages */
    .log-entry {
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-bottom: 1px solid #ddd;
    }
    .error {
      color: red;
    }
    /* Suggested Guess */
    #suggestion {
      font-size: 1.8em;
      font-weight: bold;
      color: #007bff;
      border: 2px solid #007bff;
      border-radius: 4px;
      padding: 0.3em 0.6em;
      background: #e7f0fd;
      display: inline-block;
      margin-bottom: 1rem;
    }
    /* Debug Panel */
    #debugPanel {
      display: none;
      background: #eee;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
      font-size: 0.9em;
      white-space: pre-wrap;
    }
    .debug-toggle {
      display: flex;
      align-items: center;
      margin: 1rem 0;
    }
    .debug-toggle input {
      margin-right: 0.5rem;
    }
    /* Footer */
    footer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.8em;
      color: #777;
    }
    /* Mobile Responsiveness */
    @media (max-width: 600px) {
      .container {
        padding: 1rem;
      }
      .feedback-box {
        width: 40px;
        height: 40px;
        font-size: 1.5em;
        margin-right: 0.3rem;
      }
      button {
        padding: 0.5rem 0.8rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Wordle Solver – Hybrid Strategy</h1>
    <div id="game">
      <div id="status" class="status">Loading word list…</div>
      <div id="solver" style="display:none;">
        <p><strong>Suggested Guess:</strong> <span id="suggestion"></span></p>
        <p><strong>Attempt:</strong> <span id="attemptCount">0</span> / 6</p>
        
        <!-- Feedback Input Boxes -->
        <label for="feedback">Enter Feedback (5 digits, 0=gray, 1=yellow, 2=green):</label>
        <div id="feedbackContainer">
          <input type="text" class="feedback-box" id="feedback0" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback1" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback2" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback3" maxlength="1" pattern="[0-2]" inputmode="numeric">
          <input type="text" class="feedback-box" id="feedback4" maxlength="1" pattern="[0-2]" inputmode="numeric">
        </div>
        <div style="margin-bottom:1rem;">
          <button id="submit">Submit Feedback</button>
          <button id="restart">Restart Game</button>
        </div>
        <div id="log"></div>
        <!-- Debug Toggle and Panel (placed below log) -->
        <div class="debug-toggle">
          <input type="checkbox" id="debugToggle">
          <label for="debugToggle">Debug Mode</label>
        </div>
        <div id="debugPanel"></div>
      </div>
    </div>
  </div>
  <footer>
    &copy; 2025 Ryan Lu | Licensed under GNU General Public License version 3
  </footer>
  <script>
    "use strict";
    // Constants
    const WORD_LENGTH = 5;
    const SAMPLE_SIZE = 100;
    const MAX_ATTEMPTS = 6;
    // Preselected optimal starting words (used for the first guess)
    const optimalGuesses = ["salet", "crate", "raise", "roate"];

    // Global state
    let words = [];             // Complete word list
    let remainingWords = [];    // Current candidate words
    let firstGuessCache = [];   // Cache for first guesses (optimal starting words)
    let cacheInitialized = false;
    let attemptCount = 0;
    let firstGuessUsed = false;
    let debugMode = false;
    let debugDetails = "";

    // UI elements
    const statusEl = document.getElementById("status");
    const solverEl = document.getElementById("solver");
    const suggestionEl = document.getElementById("suggestion");
    const attemptEl = document.getElementById("attemptCount");
    const submitButton = document.getElementById("submit");
    const restartButton = document.getElementById("restart");
    const logEl = document.getElementById("log");
    const debugPanel = document.getElementById("debugPanel");
    const debugToggle = document.getElementById("debugToggle");
    const feedbackBoxes = Array.from(document.querySelectorAll('.feedback-box'));

    /* ----------------------------------------
       Hybrid Candidate Selection using a
       weighted combination of entropy and frequency.
       - For each candidate word, we compute an "entropy"
         score (information gain) and a "frequency" score
         (commonness based on letter frequency in the candidate set).
       - Both scores are normalized (divided by the maximum
         found among all candidates).
       - The final hybrid score is:
             hybridScore = w * (normalizedEntropy) + (1 - w) * (normalizedFrequency)
         where w (0 ≤ w ≤ 1) is a weight parameter (default 0.5).
    ---------------------------------------- */
    const hybridWeight = 0.5; // Adjust weight (e.g., 0.5 gives equal weight)

    // Compute feedback for a guess vs. a target word.
    function computeFeedback(guess, target) {
      const feedback = new Array(WORD_LENGTH).fill(0);
      const count = new Array(26).fill(0);
      for (let i = 0; i < WORD_LENGTH; i++) {
        count[target.charCodeAt(i) - 97]++;
      }
      for (let i = 0; i < WORD_LENGTH; i++) {
        if (guess[i] === target[i]) {
          feedback[i] = 2;
          count[guess.charCodeAt(i) - 97]--;
        }
      }
      for (let i = 0; i < WORD_LENGTH; i++) {
        if (feedback[i] !== 2 && count[guess.charCodeAt(i) - 97] > 0) {
          feedback[i] = 1;
          count[guess.charCodeAt(i) - 97]--;
        }
      }
      return feedback;
    }

    // Calculate entropy for a candidate using the candidate word list.
    // (Returns only the numeric value; raw details are omitted from the webpage.)
    function calculateEntropy(wordList, candidate) {
      const patternCounts = new Array(Math.pow(3, WORD_LENGTH)).fill(0);
      wordList.forEach(word => {
        const fb = computeFeedback(candidate, word);
        let pattern = 0;
        for (let i = 0; i < WORD_LENGTH; i++) {
          pattern = pattern * 3 + fb[i];
        }
        patternCounts[pattern]++;
      });
      let entropy = 0;
      const total = wordList.length;
      for (let i = 0; i < patternCounts.length; i++) {
        if (patternCounts[i] > 0) {
          const prob = patternCounts[i] / total;
          entropy -= prob * Math.log2(prob);
        }
      }
      return entropy;
    }

    // Compute letter frequency matrix over the candidate list.
    function calculateFrequencies(wordList) {
      const freq = Array.from({ length: WORD_LENGTH }, () => new Array(26).fill(0));
      wordList.forEach(word => {
        for (let pos = 0; pos < WORD_LENGTH; pos++) {
          freq[pos][word.charCodeAt(pos) - 97]++;
        }
      });
      return freq;
    }

    // Compute frequency score for a given word based on the frequency matrix.
    function wordFrequencyScore(word, freq) {
      let score = 0;
      for (let pos = 0; pos < WORD_LENGTH; pos++) {
        score += freq[pos][word.charCodeAt(pos) - 97];
      }
      return score;
    }

    // Precompute first guess candidates (optimal starting words) using entropy.
    function precomputeFirstGuesses(wordList) {
      firstGuessCache = optimalGuesses.map(guess => ({
        word: guess,
        entropy: calculateEntropy(wordList, guess)
      }));
      cacheInitialized = true;
    }

    // Hybrid selection: combine normalized entropy and frequency score.
    function selectHybridGuess(wordList) {
      const freq = calculateFrequencies(wordList);
      let maxEntropy = 0, maxFreq = 0;
      const candidates = [];
      wordList.forEach(word => {
        const ent = calculateEntropy(wordList, word);
        const freqScore = wordFrequencyScore(word, freq);
        candidates.push({ word, ent, freqScore });
        if (ent > maxEntropy) maxEntropy = ent;
        if (freqScore > maxFreq) maxFreq = freqScore;
      });
      // Compute the weighted (hybrid) score for each candidate.
      candidates.forEach(candidate => {
        candidate.normalizedEnt = maxEntropy ? candidate.ent / maxEntropy : 0;
        candidate.normalizedFreq = maxFreq ? candidate.freqScore / maxFreq : 0;
        candidate.hybridScore = hybridWeight * candidate.normalizedEnt + (1 - hybridWeight) * candidate.normalizedFreq;
      });
      // Sort candidates by hybrid score (highest first).
      candidates.sort((a, b) => b.hybridScore - a.hybridScore);
      // For debugging (if enabled), store details about the top candidate.
      if (debugMode) {
        let details = "Hybrid Candidate Selection Details:\n";
        details += `Total Candidates: ${wordList.length}\n`;
        details += `Weighting: ${hybridWeight} for entropy, ${1 - hybridWeight} for frequency\n\n`;
        details += "Top 3 Candidates:\n";
        for (let i = 0; i < Math.min(3, candidates.length); i++) {
          details += `  ${candidates[i].word}: entropy=${candidates[i].ent.toFixed(2)} ` +
                     `(${candidates[i].normalizedEnt.toFixed(2)}), frequency=${candidates[i].freqScore} ` +
                     `(${candidates[i].normalizedFreq.toFixed(2)}), hybridScore=${candidates[i].hybridScore.toFixed(2)}\n`;
        }
        debugDetails = details;
      }
      return candidates[0].word;
    }

    // Main candidate selection function.
    function selectGuess(wordList) {
      let header = `Attempt: ${attemptCount} | Remaining Candidates: ${wordList.length}\n\n`;
      // Use precomputed optimal guess on the first attempt.
      if (!firstGuessUsed && cacheInitialized) {
        const guess = firstGuessCache.reduce((best, item) =>
          item.entropy > best.entropy ? item : best, firstGuessCache[0]).word;
        debugDetails = header + "Method: Precomputed Optimal First Guess\nChosen: " + guess;
        firstGuessUsed = true;
        return guess;
      }
      // Use hybrid selection for all subsequent guesses.
      const guess = selectHybridGuess(wordList);
      debugDetails = header + "Method: Hybrid Selection (Entropy + Frequency)";
      return guess;
    }

    // Filter candidates based on user feedback.
    function filterWords(guess, feedback, wordList) {
      return wordList.filter(word => {
        const fb = computeFeedback(guess, word);
        for (let i = 0; i < WORD_LENGTH; i++) {
          if (fb[i] !== feedback[i]) return false;
        }
        return true;
      });
    }

    // Append a message to the log.
    function logMessage(message, isError = false) {
      const entry = document.createElement("div");
      entry.className = "log-entry" + (isError ? " error" : "");
      entry.textContent = message;
      logEl.appendChild(entry);
    }

    /* ----------------------------------------
       UI & Game Logic
    ---------------------------------------- */
    function updateUI() {
      if (remainingWords.length === 0) {
        suggestionEl.textContent = "No possible words remain.";
        submitButton.disabled = true;
        return;
      }
      const guess = selectGuess(remainingWords);
      suggestionEl.textContent = guess;
      attemptEl.textContent = attemptCount.toString();
      if (debugMode) {
        debugPanel.style.display = "block";
        debugPanel.textContent = debugDetails;
      } else {
        debugPanel.style.display = "none";
      }
    }

    // Read feedback from individual boxes.
    function getFeedbackFromBoxes() {
      const fbArray = [];
      for (let i = 0; i < WORD_LENGTH; i++) {
        const val = feedbackBoxes[i].value.trim();
        if (!/^[0-2]$/.test(val)) return null;
        fbArray.push(parseInt(val, 10));
      }
      return fbArray;
    }

    // Process user feedback.
    function processFeedback() {
      const guess = suggestionEl.textContent;
      const fbArray = getFeedbackFromBoxes();
      if (!fbArray) {
        logMessage("Invalid feedback. Please enter digits 0-2 in all boxes.", true);
        return;
      }
      logMessage(`Attempt ${attemptCount + 1}: Guess "${guess}" with feedback "${fbArray.join('')}"`);
      const solved = fbArray.every(val => val === 2);
      if (solved) {
        logMessage(`Solved in ${attemptCount + 1} attempts!`);
        suggestionEl.textContent = "✓";
        submitButton.disabled = true;
        feedbackBoxes.forEach(box => box.disabled = true);
        return;
      }
      remainingWords = filterWords(guess, fbArray, remainingWords);
      logMessage(`Remaining possible words: ${remainingWords.length}`);
      attemptCount++;
      if (attemptCount >= MAX_ATTEMPTS) {
        if (remainingWords.length > 1) {
          logMessage("Maximum attempts reached. Possible solutions:");
          remainingWords.slice(0, 10).forEach(word => logMessage("  " + word));
          if (remainingWords.length > 10) {
            logMessage(`... and ${remainingWords.length - 10} more`);
          }
        }
        suggestionEl.textContent = "Game Over";
        submitButton.disabled = true;
        feedbackBoxes.forEach(box => box.disabled = true);
      } else {
        feedbackBoxes.forEach(box => box.value = "");
        updateUI();
      }
    }

    // Restart the game.
    function restartGame() {
      attemptCount = 0;
      firstGuessUsed = false;
      remainingWords = [...words];
      logEl.innerHTML = "";
      feedbackBoxes.forEach(box => {
        box.value = "";
        box.disabled = false;
      });
      submitButton.disabled = false;
      updateUI();
    }

    /* ----------------------------------------
       Feedback Boxes Navigation:
         - Auto-advance on input/backspace.
         - Navigate with left/right arrow keys.
         - Enter key submits feedback.
    ---------------------------------------- */
    feedbackBoxes.forEach((box, index) => {
      box.addEventListener("input", () => {
        if (box.value.length === 1 && index < WORD_LENGTH - 1) {
          feedbackBoxes[index + 1].focus();
        }
      });
      box.addEventListener("keydown", (e) => {
        if (e.key === "Backspace" && box.value === "" && index > 0) {
          feedbackBoxes[index - 1].focus();
        }
        if (e.key === "ArrowLeft" && index > 0) {
          feedbackBoxes[index - 1].focus();
        }
        if (e.key === "ArrowRight" && index < WORD_LENGTH - 1) {
          feedbackBoxes[index + 1].focus();
        }
      });
      box.addEventListener("keyup", (e) => {
        if (e.key === "Enter") {
          processFeedback();
        }
      });
    });

    // Toggle debug mode.
    debugToggle.addEventListener("change", () => {
      debugMode = debugToggle.checked;
      if (!debugMode) {
        debugPanel.style.display = "none";
      } else {
        debugPanel.style.display = "block";
        debugPanel.textContent = debugDetails;
      }
    });

    /* ----------------------------------------
       Initialization: Load word list from "words.txt"
    ---------------------------------------- */
    function init() {
      fetch("words.txt")
        .then(response => {
          if (!response.ok) throw new Error("Network response was not ok");
          return response.text();
        })
        .then(text => {
          words = text.split(/\r?\n/).map(line => line.trim().toLowerCase())
                        .filter(word => word.length === WORD_LENGTH);
          if (words.length === 0) throw new Error("No valid words found in words.txt");
          remainingWords = [...words];
          precomputeFirstGuesses(words);
          statusEl.style.display = "none";
          solverEl.style.display = "block";
          updateUI();
        })
        .catch(error => {
          statusEl.textContent = "Error loading word list: " + error.message;
          console.error(error);
        });
    }

    document.addEventListener("DOMContentLoaded", init);
    submitButton.addEventListener("click", processFeedback);
    restartButton.addEventListener("click", restartGame);
  </script>
</body>
</html>
